# 锁及锁的优化

> 线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。
>
> Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“**偏向锁**”和“**轻量级锁**”，所以在Java SE1.6里锁一共有四种状态，**无锁**状态，**偏向锁**状态，**轻量级锁**状态和**重量级锁**状态，它会随着竞争情况逐渐升级。
>
> 锁可以**升级**但不能**降级**，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

## 1.偏向锁
### 1.1 什么是偏向锁
偏向锁是JDK1.6提出了的一种锁优化机制。其核心思想是：**如果程序没有竞争，则取消之前已经取得锁的线程同步操作。**  
也就是说，若某一锁被线程获取后，便进入偏向模式，当线程再次请求这个锁时，就无需再进行相关的同步操作了，消除这个线程锁重入（CAS）的开销，如果在此之间有其他的线程进行了锁请求，则锁退出偏向模式。

### 1.2 偏向锁的获取
1. 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID
2. 当该线程再次进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁
3. 如果测试成功，表示线程已经获得了锁
4. 如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

### 1.2 偏向锁的释放
> 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

### 1.3 如何使用偏向锁
偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如想自定义延长时间可以使用如下命令设置延长时间 ：

    -XX：BiasedLockingStartupDelay = 0

如果程序的锁经常处于竞争状态，可以关闭偏向锁，关闭后进入轻量级锁：

    -XX:-UseBiasedLocking=false

## 2. 自旋锁

> 频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。同时很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁。

### 2.1 什么是自旋锁
所谓“**自旋**”，就是让线程去执行一个**无意义的循环**，循环结束后再去重新竞争锁，如果竞争不到继续**循环**。  

循环过程中线程会一直处于Running状态，但是基于JVM的线程调度，会**出让时间片**，所以其他线程依旧有申请锁和释放锁的机会。

### 2.2 自旋锁的优劣
自旋锁省去了阻塞锁的时间空间（队列的维护等）开销，但是**长时间**自旋就变成了“**忙式等待**”，忙式等待显然还不如阻塞锁。所以自旋的次数一般控制在一个范围内，例如10,100等，在超出这个范围后，自旋锁会**升级为阻塞锁**。

### 2.3 自旋锁的设置
对自旋锁周期的选择上，HotSpot认为最佳时间应是一个线程上下文切换的时间，但目前并没有做到。  
经过调查，目前只是通过汇编暂停了几个CPU周期，除了自旋周期选择，HotSpot还进行许多其他的自旋优化策略，具体如下：

如果平均负载小于CPUs则一直自旋
如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞
如果正在自旋的线程发现Owner发生了变化则延迟自旋时间（自旋计数）或进入阻塞 如果CPU处于节电模式则停止自旋
自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差）